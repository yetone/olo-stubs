from typing import TypeVar, Container, Generic, Tuple, Union

from olo.expression import UnaryExpression, BinaryExpression
from olo.query import Query

T = TypeVar('T')
F = TypeVar('F', bound='BinaryOperationMixin')
F0 = TypeVar('F0', bound='UnaryOperationMixin')
C = Union[Query[T], Container[T]]


class UnaryOperationMixin:
    def desc(self: F0) -> UnaryExpression[F0]: ...
    def asc(self: F0) -> UnaryExpression[F0]: ...


class BinaryOperationMixin(Generic[T]):

    def in_(self: F, other: C[T]) -> BinaryExpression[F, Container[T]]: ...

    def not_in_(self: F, other: C[T]) -> BinaryExpression[F, Container[T]]: ...

    def like_(self: F, other: str) -> BinaryExpression[F, str]: ...

    def ilike_(self: F, other: str) -> BinaryExpression[F, str]: ...

    def regexp_(self: F, other: str) -> BinaryExpression[F, str]: ...

    def between_(self: F, other: Tuple) -> BinaryExpression[F, Tuple]: ...

    def concat_(self: F, other: T) -> BinaryExpression[F, T]: ...

    def is_(self: F, other: T) -> BinaryExpression[F, T]: ...

    def is_not_(self: F, other: T) -> BinaryExpression[F, T]: ...

    def __add__(self: F, other: T) -> BinaryExpression[F, T]: ...
    def __radd__(self: F, other: T) -> BinaryExpression[F, T]: ...
    def __sub__(self: F, other: T) -> BinaryExpression[F, T]: ...
    def __rsub__(self: F, other: T) -> BinaryExpression[F, T]: ...
    def __mul__(self: F, other: T) -> BinaryExpression[F, T]: ...
    def __div__(self: F, other: T) -> BinaryExpression[F, T]: ...
    def __truediv__(self: F, other: T) -> BinaryExpression[F, T]: ...
    def __mod__(self: F, other: T) -> BinaryExpression[F, T]: ...
    def __eq__(self: F, other: T) -> BinaryExpression[F, T]: ...
    def __ne__(self: F, other: T) -> BinaryExpression[F, T]: ... # type: ignore[override]
    def __gt__(self: F, other: T) -> BinaryExpression[F, T]: ... # type: ignore[override]
    def __ge__(self: F, other: T) -> BinaryExpression[F, T]: ... # type: ignore[override]
    def __lt__(self: F, other: T) -> BinaryExpression[F, T]: ... # type: ignore[override]
    def __le__(self: F, other: T) -> BinaryExpression[F, T]: ... # type: ignore[override]
    def __lshift__(self: F, other: T) -> BinaryExpression[F, T]: ...
